# ArtClubQuizGenerics
ArtBrains ArtClub Topic on Generics in Java Puzzlers

## Answer to Pazzlers with explanations

1. --Clone.java--
  * Well, a quite easy puzzler. Despite we ensure compiler that generic < T > extends Clonable, we still get compilation error - *'clone() has protected access in java.lang.Object'*
2. --Compressor.java--
  * For the first time everything looks OK. But, after a closer look you notice that we create instance of class Compressor without any generic parametrization. Even if don't use it anywhere in code thus will brack everything up due to type erasure. We will no longer have 2 generalized overload methods, but methods with raw types. And when runtime will get this code, he will try to use the narrowest method he could - *int compress(List list)* and will throw __ClassCastException__ in there: we really cann't cast String to int :(
3. --ConcreateList.java--
  * Well, it's not an easy one. The program will fail with __ClassCastException__ with (java.lang.Object; cannot be cast to Ljava.lang.String). To get why this is happening you should learn about bridge methods which are synthetically generated by compiler. If you will look into compiled classes you'll find that Java compiler eliminate generics with casts in ConcreateList class- _stringList.addNotNull(new String[]{"null", null})_, **BUT** in abstract DefaulList implementation is different - _this.add(new Object[]{element})_ and thus will give you an exception described above.
4. --ILoveExceptions.java--
  * To solve this you just need to be a little bit attentive. What we got here is a usless cast to type < T > and the method when it come to try block will just successfully return 42 as Integer. But (!), on a runtime in main method we don't already have an out.println() method which took Object, but String! And here we will face **ClassCastException**
5. --IntegerIteration.java--
  * A similar puzzler to _Compressor.java_. We forget to instantiate calss IntegerItearation wit generic! And all generic types wipes out! So we will get __ClassCastException__ in foreach loop
6. --SetSize.java--
  * To solve this, You need to rememeber what a TreeSet is and how it works. And if you're clever enough to remember how method compareTo() works, your answer, without a doubt, be __ClassCastException__
7. --StringIsFinal.java--
  * The wierdest one. Honestly, its a bug. We can assign any raw interface to any object, the compiler just don't care of it ;(
8. --TryToHackCompiler.java--
  * Never, do you hear me(?), never ignore compilator's warnings. In this case, when we assign parametrized list into raw Compile canceled Generic contract for us and if we look into bytecode we find only one created ArrayList - a raw typed _ArrayList integers = new ArrayList()_. So never do that! In both suot's we will get 9.78.
9. --TypeInferenceOverdose.java--
  * The problem of Type Inference. Compiler try to infer type and succsed at it! So this code will compile even if we will switch Integer.object to int.
